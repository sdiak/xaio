#ifndef XAIO_H
#define XAIO_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef _Nonnull
#   define _Nonnull
#endif
#ifndef AtomicUsize
#   define AtomicUsize _Atomic uintptr_t
#endif
#if !defined(__GNUC__) && !defined(__clang__)
#   define __attribute__()
#endif
#if defined(_WIN32) || defined(_WIN64)
    typedef uintptr_t xsocket_t;
    typedef void *xfile_t;
#else
    typedef int xsocket_t;
    typedef int xfile_t;
#endif
    

/**
 * Tries to reuse the sharable driver handle in `xdriver_params_s::attach_handle
 */
#define XDRIVER_FLAG_ATTACH_HANDLE 1u

#define XDRIVER_FLAG_CLOSE_ON_EXEC 2u

struct xring_s;

/**
 * A thread-local completion port
 */
struct xcp_s {
  uintptr_t prv__thread_id;
  uint32_t prv__id;
  uint32_t prv__refcount;
  int64_t prv__now;
};

typedef bool (*xdriver_is_supported_m)(void);

/**
 * IO Driver parameters
 */
struct xdriver_params_s {
  /**
   * submission queue depth
   */
  int32_t submission_queue_depth;
  /**
   * completion queue depth
   */
  int32_t completion_queue_depth;
  /**
   * kernel busy-polling loop timeout in milliseconds, a value of <= 0 deactivate kernel polling
   */
  int32_t kernel_poll_timeout_ms;
  /**
   * Flags
   */
  uint32_t flags;
  /**
   * A sharable driver handle when (flags & XDRIVER_FLAG_ATTACH_HANDLE)
   */
  uintptr_t attach_handle;
  /**
   * An hint on the maximal number of file descriptor
   */
  int32_t max_number_of_fd_hint;
  int32_t reserved_;
};

typedef struct xdriver_params_s *_Nonnull (*xdriver_default_params_m)(struct xdriver_params_s *_Nonnull params);

typedef int32_t (*xdriver_open_m)(void *_Nonnull thiz, const struct xcp_s *_Nonnull port);

typedef void (*xdriver_close_m)(void *_Nonnull thiz, const struct xcp_s *_Nonnull port);

/**
 * Get the driver native handle
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `phandle` `*phandle` receives the native handle on success
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `thiz == NULL`
 *   -  `-EBADF` when this driver is not backed by a native handle
 */
typedef int32_t (*xdriver_get_native_handle_m)(const void *_Nonnull thiz,
                                               uintptr_t *_Nonnull phandle);

/**
 * Wait for at least one event or for the given timeout to expire.
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `timeout_ms` give up after `timeout_ms` milliseconds when `timeout_ms >= 0` (otherwize wait forever)
 *   - `events_sink` destination storage for the completed events
 *
 * # Returns
 *  - `>= 0` the number of completed events
 *  - `< 0` an error descriptor
 */
typedef int32_t (*xdriver_wait_m)(void *_Nonnull thiz, int32_t timeout, void *_Nonnull events_sink);

struct xaio_s {
  struct xcp_s *prv__cp;
  int32_t prv__status;
  uint32_t prv__flags_and_op_code;
  AtomicUsize prv__next;
};

/**
 * Submits a new asynchronous operation
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `op` the **moved** asynchronous operation, the driver owns this memory until it release it in `xdriver_class_s::wait`
 *
 * # Returns
 *  - `0` on success,
 *  - `-ENOSYS` when the operation op-code is not supported,
 *  - `-EBUSY` when the completion queue is full and the user should call `xdriver_class_s::wait`,
 *  - `<= 0` any other error reported by the underlying system io multiplexer.
 */
typedef int32_t (*xdriver_submit_m)(void *_Nonnull thiz, struct xaio_s *_Nonnull op);

/**
 * Attemps to cancel an asynchronous operation,
 * when this method succeed, the operation will not appear in `xdriver_class_s::wait` and the caller owns the memory.
 * when this method fail, the operation will eventually appears in `xdriver_class_s::wait` with or without a status of `-ECANCELED`.
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `op` the asynchronous operation
 *
 * # Returns
 *  - `0` on success,
 *  - `-ENOENT` when the operation was not found,
 *  - `-EALREADY` when the operation is in progress,
 *  - `-EBUSY` when the completion queue is full and the user should call `xdriver_class_s::wait`,
 */
typedef int32_t (*xdriver_cancel_m)(void *_Nonnull thiz, const struct xaio_s *_Nonnull op);

/**
 * IO Driver class
 */
struct xdriver_class_s {
  const char *name;
  uint32_t flags;
  uint32_t instance_align;
  uintptr_t instance_size;
  xdriver_is_supported_m is_supported;
  xdriver_default_params_m default_params;
  xdriver_open_m open;
  xdriver_close_m close;
  xdriver_get_native_handle_m get_native_handle;
  xdriver_wait_m wait;
  xdriver_submit_m submit;
  xdriver_cancel_m cancel;
};

/**
 * IO Driver
 */
struct xdriver_s {
  const struct xdriver_class_s *_Nonnull clazz;
  struct xdriver_params_s params;
};

struct xevent_s {
  int32_t status;
  uint32_t flags;
  uint64_t token;
};

/**
 * Work callback.
 *
 * # Arguments
 *   - `work_arg` argument passed to `xring_submit_work`
 *
 * # Returns
 *   -  `>=0` on success
 *   -  `<0` on error
 */
typedef int32_t (*xwork_cb)(void *work_arg);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new completion port bound to the current thread.
 *
 * # Arguments
 *   - `pport` `*pport` receives a new completion port address or `NULL` on error.
 *   - `opt_driver` driver to **move** to the port or `NULL` to use the default driver.
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `pport == NULL`
 *   -  `-ENOMEM` when the system is out of memory
 */
extern int32_t xcp_new(struct xcp_s **pport);

/**
 * Creates a new ring.
 *
 * # Arguments
 *   - `pring` `*pring` receives the new ring address or `NULL` on error.
 *   - `opt_driver` driver to **move** to the ring or `NULL` to use the default driver.
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `pring == NULL`
 *   -  `-ENOMEM` when the system is out of memory
 */
int32_t xnew(struct xring_s **pring, struct xdriver_s *opt_driver);

/**
 * Submit batched submissions then wait for up to `timeout_ms` for events, the wait will stop as soon as a completion event is present.
 *
 * # Arguments
 *   - `ring` the completion ring,
 *   - `events` an array to receive the completion events,
 *   - `capacity` the capacity of `events`,
 *   - `timeout_ms` the maximum amount of time to wait for events or `<0` for infinity,
 *
 * # Returns
 *   -  `>0` the number of completion events stored in `events`
 *   -  `0` on timeout
 *   -  `-EINVAL` when `ring == NULL`
 *   -  `-EINVAL` when `events == NULL`
 *   -  `-EINVAL` when `capacity <= 0`
 *   -  `<0` the error code returned by the underlying subsystem
 */
int32_t xsubmit_and_wait(struct xring_s *ring,
                         struct xevent_s *events,
                         int32_t capacity,
                         int32_t timeout_ms);

/**
 * Tries to cancel the submission associated to the given token.
 * The submission associated to the token will still be retreived by `xring_wait` even
 * when this function returns `0`.
 *
 * # Arguments
 *   - `ring` the completion ring,
 *   - `token` a token associated to a submissions,
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `ring == NULL`
 *   -  `-EBUSY` when the completion queue is full, the caller should call `xsubmit_and_wait(..., timeout_ms=0)` and try again
 *   -  `-ENOENT` when the submission associated to the token were not found
 *   -  `-EALREADY` when the associated submission has progressed far enough that cancelation is no longer possible
 */
int32_t xcancel(struct xring_s *ring,
                uint64_t token,
                bool all);

/**
 * Submit some work to the IO thread pool
 *
 * # Arguments
 *   - `ring` the completion ring,
 *   - `token` a token associated to the submission,
 *   - `work_cb` the work function pointer,
 *   - `work_arg` the argument to pass to `work_cb`,
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `ring == NULL`
 *   -  `-EBUSY` when the submission queue or the completion queue is full, the caller
 * should call `xsubmit_and_wait` and try again
 *   -  `-EEXIST` when `token` is already associated to a submission
 *   -  `-EINVAL` when `work_cb == (xwork_cb)0`
 *   -  `-ENOMEM` when the system is out of memory
 *   -  `<0` the error code returned by the underlying subsystem
 */
int32_t xio_work(struct xring_s *ring, uint64_t token, xwork_cb work_cb, void *work_arg);

int32_t xsend(struct xring_s *ring, uint64_t token, xsocket_t socket);

void xdriver_params_default(struct xdriver_params_s *_Nonnull params);

const struct xdriver_class_s *_Nonnull xdriver_class_default(void);

/**
 * Creates a new driver.
 *
 * # Arguments
 *   - `pdriver` `*pdriver` receives the new driver address or `NULL` on error.
 *   - `opt_clazz` Optional clazz or `NULL` for defaults.
 *   - `opt_params` Optional parameters hints or `NULL` for defaults.
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `pdriver == NULL`
 *   -  `-ENOMEM` when the system is out of memory
 */
__attribute__((warn_unused_result))
int32_t xdriver_new(struct xdriver_s **pdriver,
                    const struct xdriver_class_s *opt_clazz,
                    const struct xdriver_params_s *opt_params);

extern int *errno_location(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* XAIO_H */

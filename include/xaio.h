#ifndef XAIO_H
#define XAIO_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef _Nonnull
#   define _Nonnull
#endif
#ifndef AtomicUsize
#   define AtomicUsize _Atomic uintptr_t
#endif
#if !defined(__GNUC__) && !defined(__clang__)
#   define __attribute__()
#endif
    

/**
 * Tries to reuse the sharable driver handle in `xdriver_params_s::attach_handle
 */
#define XDRIVER_FLAG_ATTACH_HANDLE 1u

#define XDRIVER_FLAG_CLOSE_ON_EXEC 2u

/**
 * A thread-local completion port
 */
struct xcp_s {
  uintptr_t prv__thread_id;
  uint32_t prv__id;
  uint32_t prv__refcount;
  int64_t prv__now;
};

/**
 * IO Driver parameters
 */
struct xdriver_params_s {
  /**
   * submission queue depth
   */
  int32_t submission_queue_depth;
  /**
   * completion queue depth
   */
  int32_t completion_queue_depth;
  /**
   * kernel busy-polling loop timeout in milliseconds, a value of <= 0 deactivate kernel polling
   */
  int32_t kernel_poll_timeout_ms;
  /**
   * Flags
   */
  uint32_t flags;
  /**
   * A sharable driver handle when (flags & XDRIVER_FLAG_ATTACH_HANDLE)
   */
  uintptr_t attach_handle;
  /**
   * An hint on the maximal number of file descriptor
   */
  int32_t max_number_of_fd_hint;
  int32_t reserved_;
};

typedef bool (*xdriver_is_supported_m)(void);

typedef struct xdriver_params_s *_Nonnull (*xdriver_default_params_m)(struct xdriver_params_s *_Nonnull params);

typedef int32_t (*xdriver_open_m)(void *_Nonnull thiz, const struct xcp_s *_Nonnull port);

typedef void (*xdriver_close_m)(void *_Nonnull thiz, const struct xcp_s *_Nonnull port);

/**
 * Get the driver native handle
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `phandle` `*phandle` receives the native handle on success
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `thiz == NULL`
 *   -  `-EBADF` when this driver is not backed by a native handle
 */
typedef int32_t (*xdriver_get_native_handle_m)(const void *_Nonnull thiz,
                                               uintptr_t *_Nonnull phandle);

/**
 * Wait for at least one event or for the given timeout to expire.
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `timeout_ms` give up after `timeout_ms` milliseconds when `timeout_ms >= 0` (otherwize wait forever)
 *   - `events_sink` destination storage for the completed events
 *
 * # Returns
 *  - `>= 0` the number of completed events
 *  - `< 0` an error descriptor
 */
typedef int32_t (*xdriver_wait_m)(void *_Nonnull thiz, int32_t timeout, void *_Nonnull events_sink);

struct xaio_s {
  struct xcp_s *prv__cp;
  int32_t prv__status;
  uint32_t prv__flags_and_op_code;
  AtomicUsize prv__next;
};

/**
 * Submits a new asynchronous operation
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `op` the **moved** asynchronous operation, the driver owns this memory until it release it in `xdriver_class_s::wait`
 *
 * # Returns
 *  - `0` on success,
 *  - `-ENOSYS` when the operation op-code is not supported,
 *  - `-EBUSY` when the completion queue is full and the user should call `xdriver_class_s::wait`,
 *  - `<= 0` any other error reported by the underlying system io multiplexer.
 */
typedef int32_t (*xdriver_submit_m)(void *_Nonnull thiz, struct xaio_s *_Nonnull op);

/**
 * Attemps to cancel an asynchronous operation,
 * when this method succeed, the operation will not appear in `xdriver_class_s::wait` and the caller owns the memory.
 * when this method fail, the operation will eventually appears in `xdriver_class_s::wait` with or without a status of `-ECANCELED`.
 *
 * # Arguments
 *   - `thiz` the driver instance
 *   - `op` the asynchronous operation
 *
 * # Returns
 *  - `0` on success,
 *  - `-ENOENT` when the operation was not found,
 *  - `-EALREADY` when the operation is in progress,
 *  - `-EBUSY` when the completion queue is full and the user should call `xdriver_class_s::wait`,
 */
typedef int32_t (*xdriver_cancel_m)(void *_Nonnull thiz, const struct xaio_s *_Nonnull op);

/**
 * IO Driver class
 */
struct xdriver_class_s {
  const char *name;
  uint32_t flags;
  uint32_t instance_align;
  uintptr_t instance_size;
  xdriver_is_supported_m is_supported;
  xdriver_default_params_m default_params;
  xdriver_open_m open;
  xdriver_close_m close;
  xdriver_get_native_handle_m get_native_handle;
  xdriver_wait_m wait;
  xdriver_submit_m submit;
  xdriver_cancel_m cancel;
};

/**
 * IO Driver
 */
struct xdriver_s {
  const struct xdriver_class_s *_Nonnull clazz;
  struct xdriver_params_s params;
};

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new completion port bound to the current thread.
 *
 * # Arguments
 *   - `pport` `*pport` receives a new completion port address or `NULL` on error.
 *   - `opt_driver` driver to **move** to the port or `NULL` to use the default driver.
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `pport == NULL`
 *   -  `-ENOMEM` when the system is out of memory
 */
extern int32_t xcp_new(struct xcp_s **pport);

struct xdriver_params_s *xdriver_params_default(struct xdriver_params_s *params);

const struct xdriver_class_s *_Nonnull xdriver_class_default(void);

/**
 * Creates a new driver.
 *
 * # Arguments
 *   - `pdriver` `*pdriver` receives the new driver address or `NULL` on error.
 *   - `opt_clazz` Optional clazz or `NULL` for defaults.
 *   - `opt_params` Optional parameters hints or `NULL` for defaults.
 *
 * # Returns
 *   -  `0` on success
 *   -  `-EINVAL` when `pdriver == NULL`
 *   -  `-ENOMEM` when the system is out of memory
 */
__attribute__((warn_unused_result))
int32_t xdriver_new(struct xdriver_s **pdriver,
                    const struct xdriver_class_s *opt_clazz,
                    const struct xdriver_params_s *opt_params);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* XAIO_H */
